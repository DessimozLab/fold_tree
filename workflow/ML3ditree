#once snakemake is installed use the following command to test the struct tree
import snakemake.utils
snakemake.utils.min_version("7.8.0")
snake_dir = workflow.basedir
rootdir = ''.join([ sub + '/' for sub in snake_dir.split('/')[:-1] ] )
print(rootdir)

configfile: rootdir+ "workflow/config/config_vars.yaml"
# remote homologues search parameters

foldseekpath = config["foldseek_path"]
if foldseekpath == 'provided':
	foldseekpath = rootdir + "foldseek/foldseek"

if 'folder' in config:
	folders = [config['folder']]
else:
	folders = glob_wildcards("{folders}/identifiers.txt").folders

alntype = ['3di','AA', 'foldtree']
print(folders[0:100] , '...')


def get_mem_mb(wildcards, attempt):
	return attempt * 20000

rule all:
	input:
	#get all treescore and rf distance files for all alntypes
		expand("{folder}/templateX{alntype}.nx.treefile.rooted.final", folder = folders , alntype = alntype),
		expand("{folder}/templateX{alntype}.nx.treefile.rooted.final.treescore", folder = folders , alntype = alntype),

rule treescore:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/sequence_dataset.csv",
		"{folder}/templateX{alntype}.nx.treefile.rooted.final",
	output:
		"{folder}/templateX{alntype}.nx.treefile.rooted.final.treescore",
	log:
		"{folder}/logs/treescore_{alntype}.log"
	script:
		'../src/calc_treescores.py'

rule mad_root_postML:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/templateX{alntype}.nx.treefile.rooted"
	output:
		"{folder}/templateX{alntype}.nx.treefile.rooted.final"
	log:
		"{folder}/logs/structML_madroot_post_{alntype}.log"
	script:
		'../src/process_madroot.py'
	
rule mad_root_structML:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/templateX{alntype}.nx.treefile"
	output:
		"{folder}/templateX{alntype}.nx.treefile.rooted"
	log:
		"{folder}/logs/structML_madroot_{alntype}.log"
	shell:
		rootdir+'madroot/mad {wildcards.folder}/templateX{wildcards.alntype}.nx.treefile'

rule mad_root_post:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/struct_tree.PP.nwk"
	output:
		"{folder}/struct_tree.PP.nwk.rooted.final"
	log:
		"{folder}/logs/struct_madroot_post.log"
	script:
		'../src/process_madroot.py'
	
rule mad_root_struct:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/struct_tree.PP.nwk"
	output:
		"{folder}/struct_tree.PP.nwk.rooted"
	log:
		"{folder}/logs/struct_madroot.log"
	shell:
		rootdir+'madroot/mad {wildcards.folder}/struct_tree.PP.nwk'

rule postprocess:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/struct_tree.nwk"
	output:
		"{folder}/struct_tree.PP.nwk"
	log:
		"{folder}/logs/struct_postprocess.log"
	script:
		'../src/postprocess.py'

rule iqtreex:
	resources:
		mem_mb=get_mem_mb
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/alnAA_{alntype}.fasta",
		"{folder}/aln3di_{alntype}.fasta",
		"{folder}/templateX{alntype}.nx"
	output:
		"{folder}/templateX{alntype}.nx.treefile"
	params:
		cores=config["iqtree_cores"],
	log:
		"{folder}/logs/3diAA_iqtree_{alntype}.log"
	shell:
		'iqtree -p {wildcards.folder}/templateX{wildcards.alntype}.nx  -T {params.cores} -redo '

rule iqtree_template:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/alnAA_{alntype}.fasta",
		"{folder}/aln3di_{alntype}.fasta",
	output:
		"{folder}/templateX{alntype}.nx",
	params:
		submat=rootdir+config["submat3di"]
	log:
		"{folder}/logs/template_iqtree_{alntype}.log"
	script:
		#todo change this to use the partition file and the model
		'../src/create_iqtree_template.py' 

rule cross_alns:
	#transfer 3di logic to to AA seq	
	#transfer seq aln logic to 3di sequences
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/alnAA_AA.fasta",
		"{folder}/aln3di_3di.fasta",
	output:
		"{folder}/alnAA_3di.fasta",
		"{folder}/aln3di_AA.fasta",
	log:
		"{folder}/logs/cross_alns.log"
	script:
		"../src/crossalns.py"

rule mafft_textaln:
	#use the 3di submat to aln the 3di sequences
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/seq3di.fasta",
	output:
		"{folder}/aln3di_3di.fasta",
	params:
		submat=rootdir+config["mafft_submat3di"]
	shell:
		'mafft --textmatrix {params.submat} {input} > {output}'
	
rule mafft_seq:
	#use a normal sequence alignment tool to align the AA sequences
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/sequences.fst",
	output:
		"{folder}/alnAA_AA.fasta",
	shell:
		'mafft {input} > {output}'

rule scrape_alns:
	#use 3di and AA from foldseek
	#scrape the 3di alphabet and use alignment logic to calculate new fident
	#working on merging the alns progressively for a blend of struct and seq
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/allvall_1.csv",
		"{folder}/struct_tree.PP.nwk.rooted.final",
		"{folder}/outdb",
		"{folder}/outdb_ss"
	output:
		"{folder}/seq3di.fasta",
		"{folder}/alnAA_foldtree.fasta",
		"{folder}/aln3di_foldtree.fasta",
	params:
		dbname="outdb"
	log:
		"{folder}/logs/scrape_alns.log"
	script:
		"../src/add_structalns.py"

rule quicktree:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/foldtree_fastmemat.txt"
	output:
		"{folder}/struct_tree.nwk"
	log:
		"{folder}/logs/quicktree.log"
	shell:
		'quicktree -i m {wildcards.folder}/foldtree_fastmemat.txt > {wildcards.folder}/struct_tree.nwk '

rule foldseek2distmat:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/allvall_1.csv"
	output:
		"{folder}/foldtree_fastmemat.txt",
		"{folder}/alntmscore_fastmemat.txt",
		"{folder}/lddt_fastmemat.txt",
	params:
		fmt='query,target,fident,alnlen,mismatch,gapopen,qstart,qend,tstart,tend,evalue,bits,lddt,qaln,taln,cigar,alntmscore'
	log:
		"{folder}/logs/foldseek2distmat.log"
	script:
		"../src/foldseekres2distmat_simple.py"

rule foldseek_allvall_1:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/finalset.csv"
	output:
		"{folder}/allvall_1.csv"
	log:
		"{folder}/logs/foldseekallvall.log"
	shell:
		foldseekpath + " easy-search {wildcards.folder}/structs/ {wildcards.folder}/structs/ {wildcards.folder}/allvall_1.csv {wildcards.folder}/tmp --format-output 'query,target,fident,alnlen,mismatch,gapopen,qstart,qend,tstart,tend,evalue,bits,lddt,qaln,taln,cigar,alntmscore' --exhaustive-search --alignment-type 2 -e inf --threads " + str(config['foldseek_cores']) 

rule foldseek_createdb:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/finalset.csv"
	output:
		"{folder}/outdb",
		"{folder}/outdb_ss"
	log:
		"{folder}/logs/foldseekallvall.log"
	shell:
		foldseekpath + " createdb {wildcards.folder}/structs/ {wildcards.folder}/outdb"

rule dl_ids_sequences:
	conda: 
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		ids="{folder}/identifiers.txt",
	output:
		"{folder}/sequence_dataset.csv",
	log:
		"{folder}/logs/dlsequences.log"
	params:
		custom_structs=config["custom_structs"]
	script:
		"../src/dl_sequences.py"

rule plddt:
	conda:
		#"config/fold_tree.yaml"
		"foldtree"
	input:
		"{folder}/finalset.csv",
	output:
		"{folder}/plddt.json",
	log:
		"{folder}/logs/plddt.log"
	script:
		'../src/grabplddt.py'

rule dl_ids_structs:
	input:
		"{folder}/sequence_dataset.csv",
	output:
		"{folder}/sequences.fst",
		"{folder}/finalset.csv",
	conda: 
		#"config/fold_tree.yaml"
		"foldtree",
	log:
		"{folder}/logs/dlstructs.log",
	params:
		filtervar=config["filter"],
		filtervar_min=config["filter_min"],
		filtervar_avg=config["filter_avg"],
		custom_structs=config["custom_structs"],
	script:
		"../src/dl_structs.py"
